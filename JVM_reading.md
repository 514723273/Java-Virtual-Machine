## 3.6 内存回收与分配策略
自动内存管理最终可以归结为自动化地解决了两个**问题**：给对象*分配*内存 和 *回收*分配给对象的内存。

### 3.6.1　对象优先在Eden分配
大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

**注意**　Minor GC和Full GC有什么不一样吗？
- 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝
生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
- 老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴
随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行
Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。

### 3.6.2　大对象直接进入老年代
所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）
替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，**写程序的时候应当避免**

### 3.6.3　长期存活的对象将进入老年代
内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。

**举例** 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被
Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中
每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就
将会被晋升到老年代中

### 3.6.4　动态对象年龄判定
为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到
了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中*相同年龄*所有对象大小的总
和大于Survivor空间的一半，年龄大于或等于该*年龄*的对象就可以直接进入老年代，无须等
到MaxTenuringThreshold中要求的年龄。

### 3.6.5　空间分配担保
在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。
- 如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。
    - 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
        - 如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；
    - 如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。

# 第6章　类文件结构

## 6.2　无关性的基石
实现语言无关性的基础仍然是*虚拟机*和*字节码存储格式*。

Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了*Java虚拟机指令集*和*符号表*以及*若干其他辅助信息*。

## 6.3　Class类文件的结构

**注意**　任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接
口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。

Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地
排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎
全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项
时，则会按照高位在前[1]的方式分割成若干个8位字节进行存储。

Class文件格式采用一种类似于C语言结构体的伪结构来存
储数据，这种伪结构中只有两种数据类型：无符号数和表。

- 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个
字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8
编码构成字符串值。

- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地
以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张
表。

### 6.3.1　魔数与Class文件的版本
每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件
是否为一个能被虚拟机接受的Class文件。（很多文件存储标准中都使用魔数来进行身份识别，
譬如图片格式，如gif或者jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别
主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。）

紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor
Version），第7和第8个字节是主版本号（Major Version）。

### 6.3.2　常量池
紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，
它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据
项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。
